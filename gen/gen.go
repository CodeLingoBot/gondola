// Package gen does code generation to automate tedious tasks.
//
// Although you can use this package and its subpackages directly, that's not
// recommended. Instead, you should create a genfile.yaml for your package and
// use the gondola gen command to perform the code generation.
package gen

import (
	"fmt"
	"github.com/kylelemons/go-gypsy/yaml"
	"gnd.la/gen/json"
	"regexp"
	"strconv"
)

// Gen generates code according to the given config file. If the config file
// can't be found or it can't be parsed, an error will be returned. Previously
// autogenerated files will be overwritten, but trying to overwrite any files
// which were not autogenerated will also return an error. See the package
// documentation for the format of the config file.
func Gen(pkgName string, config string) error {
	if config == "" {
		pkg, err := genutil.NewPackage(pkgName)
		if err != nil {
			return err
		}
		config = filepath.Join(pkg.Dir(), "genfile.yaml")
	}
	f, err := yaml.ReadFile(config)
	if err != nil {
		return err
	}
	root, ok := f.Root.(yaml.Map)
	if !ok {
		return fmt.Errorf("top level object in genfile.yaml must be a map")
	}
	for k, v := range root {
		switch k {
		case "json":
			opts, err := jsonOptions(v)
			if err != nil {
				return err
			}
			if err := json.Gen(pkgName, opts); err != nil {
				return err
			}
		}
	}
	return nil
}

func jsonOptions(node yaml.Node) (*json.Options, error) {
	if m, ok := node.(yaml.Map); ok {
		opts := &json.Options{}
		for k, v := range m {
			switch k {
			case "marshal-json":
				opts.MarshalJSON = nodeToBool(v)
			case "include":
				if val := nodeToString(v); val != "" {
					include, err := regexp.Compile(val)
					if err != nil {
						return nil, err
					}
					opts.Include = include
				}
			case "exclude":
				if val := nodeToString(v); val != "" {
					exclude, err := regexp.Compile(val)
					if err != nil {
						return nil, err
					}
					opts.Exclude = exclude
				}
			case "methods":
				if methods, ok := v.(yaml.Map); ok {
					opts.Methods = make(map[string][]*json.Method)
					for typeName, val := range methods {
						if typeMethods, ok := val.(yaml.Map); ok {
							for methodName, node := range typeMethods {
								method := &json.Method{
									Name: methodName,
								}
								switch value := node.(type) {
								case yaml.Map:
									method.Key = nodeToString(value["key"])
									method.OmitEmpty = nodeToBool(value["omitempty"])
								case yaml.Scalar:
									method.Key = nodeToString(value)
								default:
									return nil, fmt.Errorf("method value for %s must be scalar or map", methodName)
								}
								if method.Key == "" {
									method.Key = method.Name
								}
								opts.Methods[typeName] = append(opts.Methods[typeName], method)
							}
						}
					}
				}
			}
		}
		return opts, nil
	}
	return nil, nil
}

func nodeToBool(node yaml.Node) bool {
	switch n := node.(type) {
	case yaml.List:
		return len(n) > 0
	case yaml.Map:
		return len(n) > 0
	case yaml.Scalar:
		val, _ := strconv.ParseBool(n.String())
		return val
	}
	return false
}

func nodeToString(node yaml.Node) string {
	if s, ok := node.(yaml.Scalar); ok {
		return s.String()
	}
	return ""
}
