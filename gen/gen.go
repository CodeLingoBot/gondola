// Package gen does code generation to automate tedious tasks.
//
// Although you can use this package and its subpackages directly, that's not
// recommended. Instead, you should create a genfile.yaml for your package and
// use the gondola gen command to perform the code generation.
package gen

import (
	"fmt"
	"github.com/kylelemons/go-gypsy/yaml"
	"gnd.la/gen/genutil"
	"gnd.la/gen/json"
	"gnd.la/gen/strings"
	"path/filepath"
	"regexp"
	"strconv"
	str "strings"
)

// Gen generates code according to the given config file. If the config file
// can't be found or it can't be parsed, an error will be returned. Previously
// autogenerated files will be overwritten, but trying to overwrite any files
// which were not autogenerated will also return an error. See the package
// documentation for the format of the config file.
func Gen(pkgName string, config string) error {
	if config == "" {
		pkg, err := genutil.NewPackage(pkgName)
		if err != nil {
			return err
		}
		config = filepath.Join(pkg.Dir(), "genfile.yaml")
	}
	f, err := yaml.ReadFile(config)
	if err != nil {
		return err
	}
	root, ok := f.Root.(yaml.Map)
	if !ok {
		return fmt.Errorf("top level object in genfile.yaml must be a map")
	}
	for k, v := range root {
		switch k {
		case "json":
			opts, err := jsonOptions(v)
			if err != nil {
				return err
			}
			if err := json.Gen(pkgName, opts); err != nil {
				return err
			}
		case "strings":
			opts, err := stringsOptions(v)
			if err != nil {
				return err
			}
			if err := strings.Gen(pkgName, opts); err != nil {
				return err
			}
		}
	}
	return nil
}

func jsonOptions(node yaml.Node) (*json.Options, error) {
	if m, ok := node.(yaml.Map); ok {
		opts := &json.Options{}
		var err error
		for k, v := range m {
			switch k {
			case "marshal-json":
				opts.MarshalJSON = nodeToBool(v)
			case "buffer-size":
				if opts.BufferSize, err = nodeToInt(v); err != nil {
					return nil, err
				}
			case "max-buffer-size":
				if opts.MaxBufferSize, err = nodeToInt(v); err != nil {
					return nil, err
				}
			case "buffer-count":
				if opts.BufferCount, err = nodeToInt(v); err != nil {
					return nil, err
				}
			case "buffers-per-proc":
				if opts.BuffersPerProc, err = nodeToInt(v); err != nil {
					return nil, err
				}
			case "include":
				if val := nodeToString(v); val != "" {
					include, err := regexp.Compile(val)
					if err != nil {
						return nil, err
					}
					opts.Include = include
				}
			case "exclude":
				if val := nodeToString(v); val != "" {
					exclude, err := regexp.Compile(val)
					if err != nil {
						return nil, err
					}
					opts.Exclude = exclude
				}
			case "methods":
				if methods, ok := v.(yaml.Map); ok {
					opts.Methods = make(map[string][]*json.Method)
					for typeName, val := range methods {
						if typeMethods, ok := val.(yaml.Map); ok {
							for methodName, node := range typeMethods {
								method := &json.Method{
									Name: methodName,
								}
								switch value := node.(type) {
								case yaml.Map:
									method.Key = nodeToString(value["key"])
									method.OmitEmpty = nodeToBool(value["omitempty"])
								case yaml.Scalar:
									method.Key = nodeToString(value)
								default:
									return nil, fmt.Errorf("method value for %s must be scalar or map", methodName)
								}
								if method.Key == "" {
									method.Key = method.Name
								}
								opts.Methods[typeName] = append(opts.Methods[typeName], method)
							}
						}
					}
				}
			}
		}
		return opts, nil
	}
	return nil, nil
}

func stringsOptions(node yaml.Node) (*strings.Options, error) {
	if m, ok := node.(yaml.Map); ok {
		opts := &strings.Options{}
		for k, v := range m {
			switch k {
			case "include":
				if val := nodeToString(v); val != "" {
					include, err := regexp.Compile(val)
					if err != nil {
						return nil, err
					}
					opts.Include = include
				}
			case "exclude":
				if val := nodeToString(v); val != "" {
					exclude, err := regexp.Compile(val)
					if err != nil {
						return nil, err
					}
					opts.Exclude = exclude
				}
			case "options":
				if options, ok := v.(yaml.Map); ok {
					opts.TypeOptions = make(map[string]*strings.TypeOptions)
					for typeName, val := range options {
						valMap, ok := val.(yaml.Map)
						if !ok {
							return nil, fmt.Errorf("%s type options must be a map", typeName)
						}
						typeOptions := &strings.TypeOptions{}
						tr := nodeToString(valMap["transform"])
						switch tr {
						case "":
						case "uppercase":
							typeOptions.Transform = strings.ToUpper
						case "lowercase":
							typeOptions.Transform = strings.ToLower
						default:
							return nil, fmt.Errorf("invalid transform %q", tr)
						}
						if slice := valMap["slice"]; slice != nil {
							var err error
							if typeOptions.SliceBegin, typeOptions.SliceEnd, err = parseSlice(slice); err != nil {
								return nil, err
							}
						}
						opts.TypeOptions[typeName] = typeOptions
					}
				}
			}
		}
		return opts, nil
	}
	return nil, nil
}

func nodeToBool(node yaml.Node) bool {
	switch n := node.(type) {
	case yaml.List:
		return len(n) > 0
	case yaml.Map:
		return len(n) > 0
	case yaml.Scalar:
		val, _ := strconv.ParseBool(n.String())
		return val
	}
	return false
}

func nodeToString(node yaml.Node) string {
	if s, ok := node.(yaml.Scalar); ok {
		return s.String()
	}
	return ""
}

func nodeToInt(node yaml.Node) (int, error) {
	switch n := node.(type) {
	case yaml.Scalar:
		return strconv.Atoi(n.String())
	}
	return 0, fmt.Errorf("invalid int node %v", node)
}

func parseSlice(node yaml.Node) (int, int, error) {
	switch n := node.(type) {
	case yaml.Scalar:
		return _parseSlice(n.String())
	case yaml.Map:
		if len(n) == 1 {
			for k, v := range n {
				if v == nil {
					v = yaml.Scalar("0")
				}
				return _parseSlice(fmt.Sprintf("%v:%v", k, v))
			}
		}
	}
	return 0, 0, fmt.Errorf("invalid slice spec %v", node)
}

func _parseSlice(s string) (int, int, error) {
	idx := str.Index(s, ":")
	if idx < 0 {
		return 0, 0, fmt.Errorf("slice spec must contain :")
	}
	begin := s[:idx]
	end := s[idx+1:]
	b, err := strconv.Atoi(begin)
	if err != nil {
		return 0, 0, err
	}
	if end == "" {
		return b, 0, nil
	}
	e, err := strconv.Atoi(end)
	if err != nil {
		return 0, 0, err
	}
	return b, e, nil
}
