package orm

import (
	"bytes"
	"io/ioutil"
	"os"
	"testing"
	"time"

	"gnd.la/config"
	"gnd.la/log"
	"gnd.la/orm/driver"
)

// This file contains tests that are mostly independent of the ORM drivers.
// In other words, tests in this file are for features in the ORM itself.
// All of them use a temporary SQLite database.

// Interface for testing.B and testing.T
type T interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Logf(string, ...interface{})
}

type AutoIncrement struct {
	Id int64 `orm:",primary_key,auto_increment"`
	// Must have another field, otherwise there are
	// no fields to insert
	Value string
}

type Timestamp struct {
	Id        int64 `orm:",primary_key,auto_increment"`
	Timestamp time.Time
}

type Object struct {
	Id     int64 `orm:",primary_key,auto_increment"`
	Value  string
	loaded int `orm:"-"`
	saved  int `orm:"-"`
}

type Data struct {
	Id   int64 `orm:",primary_key,auto_increment"`
	Data []byte
}

func (o *Object) Load() {
	o.loaded++
}

func (o *Object) Save() {
	o.saved++
}

type Inner struct {
	A int `orm:",omitempty"`
	B int `orm:",omitempty"`
}

type Outer struct {
	Id    int64 `orm:",primary_key,auto_increment"`
	Key   string
	Inner *Inner
}

type Composite struct {
	Id    int
	Name  string `mysql:",max_length=255"`
	Value string
}

func equalTimes(t1, t2 time.Time) bool {
	// Compare seconds, since some backends (like sqlite) loss subsecond precission
	return t1.Truncate(time.Second).Equal(t2.Truncate(time.Second))
}

func newOrm(t T, url string, logging bool) *Orm {
	// Clear registry
	globalRegistry.names = make(map[string]nameRegistry)
	globalRegistry.types = make(map[string]typeRegistry)
	o, err := New(config.MustParseURL(url))
	if err != nil {
		t.Fatal(err)
	}
	if logging {
		// Set logger
		o.SetLogger(log.Std)
		if testing.Verbose() {
			log.SetLevel(log.LDebug)
		}
	} else {
		log.SetLevel(log.LInfo)
	}
	return o
}

func (o *Orm) mustRegister(t interface{}, opts *Options) *Table {
	tbl, err := o.Register(t, opts)
	if err != nil {
		panic(err)
	}
	return tbl
}

func (o *Orm) mustInitialize() {
	if err := o.Initialize(); err != nil {
		panic(err)
	}
}

func newTmpOrm(t T) (string, *Orm) {
	f, err := ioutil.TempFile("", "sqlite-")
	if err != nil {
		t.Fatal(err)
	}
	f.Close()
	o := newOrm(t, "sqlite://"+f.Name(), true)
	o.SqlDB().Exec("PRAGMA journal_mode = WAL")
	return f.Name(), o
}

func newMemoryOrm(t T) *Orm {
	o := newOrm(t, "sqlite://:memory:", true)
	o.SqlDB().Exec("PRAGMA journal_mode = WAL")
	return o
}

func runTest(t *testing.T, f func(*testing.T, *Orm)) {
	name, o := newTmpOrm(t)
	defer o.Close()
	defer os.Remove(name)
	f(t, o)
}

func testAutoIncrement(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_AUTO_ID == 0 {
		t.Log("skipping auto increment test")
		return
	}
	o.mustRegister((*AutoIncrement)(nil), nil)
	o.mustInitialize()
	obj := &AutoIncrement{}
	o.MustSave(obj)
	if o.Driver().Capabilities()&driver.CAP_AUTO_INCREMENT != 0 {
		if obj.Id != 1 {
			t.Errorf("Invalid autoincremented id %v, expected 1", obj.Id)
		}
	} else {
		if obj.Id == 0 {
			t.Error("Invalid autogenerated id zero, expected non zero")
		}
	}
}

func testTime(t *testing.T, o *Orm) {
	o.mustRegister((*Timestamp)(nil), nil)
	o.mustInitialize()
	now := time.Now()
	t1 := &Timestamp{}
	o.MustSave(t1)
	id1 := t1.Id
	t1.Id = 0
	t1.Timestamp = now
	o.MustSave(t1)
	id2 := t1.Id
	_, err := o.One(Eq("Id", id1), &t1)
	if err != nil {
		t.Error(err)
	} else {
		if !t1.Timestamp.IsZero() {
			t.Errorf("expected zero timestamp, got %v instead", t1.Timestamp)
		}
	}
	_, err = o.One(Eq("Id", id2), t1)
	if err != nil {
		t.Error(err)
	} else {
		if !equalTimes(t1.Timestamp, now) {
			t.Errorf("invalid timestamp %v, expected %v.", t1.Timestamp, now)
		}
	}
}

func testSaveDelete(t *testing.T, o *Orm) {
	SaveTable := o.mustRegister((*Object)(nil), &Options{
		Table: "test_save",
	})
	o.mustInitialize()
	obj := &Object{Value: "Foo"}
	o.MustSaveInto(SaveTable, obj)
	id1 := obj.Id
	// This should perform an insert, even when it has a primary key
	// because the update will have 0 rows affected.
	obj.Id = id1 + 1
	o.MustSaveInto(SaveTable, obj)
	id2 := obj.Id
	count := o.Table(SaveTable).MustCount()
	if count != 2 {
		t.Errorf("expected count = 2, got %v instead", count)
	}
	// This should perform an update
	obj.Value = "Bar"
	o.MustSaveInto(SaveTable, obj)
	count = o.Table(SaveTable).MustCount()
	if count != 2 {
		t.Errorf("expected count = 2, got %v instead", count)
	}
	var obj2 *Object
	_, err := o.One(Eq("Id", id2), &obj2)
	if err != nil {
		t.Error(err)
	} else if obj2 == nil {
		t.Error("obj2 is nil")
	} else if obj2.Value != obj.Value {
		t.Errorf("bad update, expected value %q, got %q instead", obj.Value, obj2.Value)
	}
	err = o.DeleteFrom(SaveTable, obj)
	if err != nil {
		t.Error(err)
	}
	count = o.Table(SaveTable).MustCount()
	if count != 1 {
		t.Errorf("expected count = 1, got %v instead", count)
	}
	res, err := o.DeleteFromTable(SaveTable, Eq("Id", id1))
	if err != nil {
		t.Error(err)
	} else {
		aff, err := res.RowsAffected()
		if err != nil {
			t.Error(err)
		}
		if aff != 1 {
			t.Errorf("expected 1 affected rows by DELETE, got %v instead", aff)
		}
	}
	count = o.Table(SaveTable).MustCount()
	if count != 0 {
		t.Errorf("expected count = 0, got %v instead", count)
	}
}

func testData(t *testing.T, o *Orm) {
	o.mustRegister((*Data)(nil), &Options{
		Table: "test_data",
	})
	o.mustInitialize()
	data := []byte{1, 2, 3, 4, 5, 6}
	src := &Data{Data: data}
	o.MustSave(src)
	id := src.Id
	var d *Data
	_, err := o.One(Eq("Id", id), &d)
	if err != nil {
		t.Error(err)
	} else if d == nil {
		t.Error("d is nil")
	} else if !bytes.Equal(d.Data, data) {
		t.Errorf("invalid stored []byte. Want %v, got %v.", data, d.Data)
	}
}

func testInnerPointer(t *testing.T, o *Orm) {
	tags := o.Driver().Tags()
	if len(tags) == 1 && tags[0] == "datastore" {
		t.Log("skipping inner pointer test, datastore does not support them")
		return
	}
	o.mustRegister((*Outer)(nil), &Options{
		Table: "test_outer",
	})
	o.mustInitialize()
	out := Outer{Key: "foo"}
	if _, err := o.Save(&out); err != nil {
		t.Error(err)
	}
	out2 := Outer{Key: "bar", Inner: &Inner{A: 4, B: 2}}
	if _, err := o.Save(&out2); err != nil {
		t.Error(err)
	}
	var in Outer
	_, err := o.One(Eq("Key", "foo"), &in)
	if err != nil {
		t.Error(err)
	} else {
		if in.Inner != nil {
			t.Errorf("want %v, got %+v", nil, in.Inner)
		}
	}
	_, err = o.One(Eq("Key", "bar"), &in)
	if err != nil {
		t.Error(err)
	} else {
		if in.Inner != nil {
			if in.Inner.A != out2.Inner.A {
				t.Errorf("want %v, got %v", out2.Inner.A, in.Inner.A)
			}
			if in.Inner.B != out2.Inner.B {
				t.Errorf("want %v, got %v", out2.Inner.B, in.Inner.A)
			}
		} else {
			t.Errorf("want non-nil, got nil")
		}
	}
}

func testTransactions(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_BEGIN == 0 {
		t.Log("skipping transaction begin/commit/rollback test")
		return
	}
	table := o.mustRegister((*AutoIncrement)(nil), &Options{
		Table: "test_transactions",
	})
	o.mustInitialize()
	obj := &AutoIncrement{}
	tx, err := o.Begin()
	if err != nil {
		t.Error(err)
		return
	}
	tx.MustSaveInto(table, obj)
	tx.MustCommit()
	e, err := o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if !e {
		t.Error("commited object does not exist")
	}
	tx2 := o.MustBegin()
	obj.Id = 0
	tx2.MustSaveInto(table, obj)
	tx2.MustRollback()
	e, err = o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if e {
		t.Error("rolled back object exists")
	}
}

func testFuncTransactions(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_TRANSACTION == 0 {
		t.Log("skipping transaction func test")
		return
	}
	table := o.mustRegister((*AutoIncrement)(nil), &Options{
		Table: "test_transactions_func",
	})
	o.mustInitialize()
	obj := &AutoIncrement{}
	if err := o.Transaction(func(o *Orm) error {
		_, err := o.SaveInto(table, obj)
		return err
	}); err != nil {
		t.Error(err)
	}
	e, err := o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if !e {
		t.Error("commited object does not exist")
	}
	if err := o.Transaction(func(o *Orm) error {
		obj.Id = 0
		o.MustSaveInto(table, obj)
		return Rollback
	}); err != nil {
		t.Error(err)
	}
	e, err = o.Exists(table, Eq("Id", obj.Id))
	if err != nil {
		t.Error(err)
	} else if e {
		t.Error("rolled back object exists")
	}
}

func testCompositePrimaryKey(t *testing.T, o *Orm) {
	if o.Driver().Capabilities()&driver.CAP_COMPOSITE_PK == 0 {
		t.Log("skipping composite pk test")
		return
	}
	// This should fail with a duplicate PK error
	_, err := o.Register((*AutoIncrement)(nil), &Options{
		Table:      "test_composite_fail",
		PrimaryKey: []string{"non-existant"},
	})
	if err == nil {
		t.Error("expecting an error when registering duplicate PK")
	}
	// This should fail because the field can't be mapped
	_, err = o.Register((*Composite)(nil), &Options{
		Table:      "test_composite_fail",
		PrimaryKey: []string{"non-existant"},
	})
	if err == nil {
		t.Error("expecting an error when registering non-existant field as PK")
	}
	table := o.mustRegister((*Composite)(nil), &Options{
		Table:      "test_composite",
		PrimaryKey: []string{"Id", "Name"},
	})
	o.mustInitialize()
	comp := &Composite{
		Id:    1,
		Name:  "Foo",
		Value: "Bar",
	}
	o.MustSave(comp)
	c1, err := o.Count(table, nil)
	if err != nil {
		t.Error(err)
	}
	if c1 != 1 {
		t.Errorf("expecting 1 row, got %v instead", c1)
	}
	_, err = o.InsertInto(table, comp)
	if err == nil {
		t.Error("must return error because of duplicate constraint")
	}
	comp.Value = "Baz"
	o.MustSave(comp)
	var comp2 *Composite
	_, err = o.Table(table).Filter(Eq("Id", 1)).One(&comp2)
	if err != nil {
		t.Error(err)
	} else if comp2 == nil {
		t.Error("comp2 is nil")
	} else if comp2.Value != comp.Value {
		t.Errorf("value not updated. want %q, got %q", comp.Value, comp2.Value)
	}
	if comp2 == nil {
		comp2 = new(Composite)
	}
	comp2.Name = "Go!"
	o.MustSave(comp2)
	c2, err := o.Count(table, nil)
	if err != nil {
		t.Error(err)
	} else if c2 != 2 {
		t.Errorf("expecting 2 rows, got %v instead", c2)
	}
}

func testQueryAll(t *testing.T, o *Orm) {
	const count = 10
	_ = o.mustRegister((*AutoIncrement)(nil), &Options{
		Table:   "test_query_all",
		Default: true,
	})
	o.mustInitialize()
	obj := &AutoIncrement{}
	for ii := 0; ii < count; ii++ {
		obj.Id = 0
		o.MustInsert(obj)
	}
	var pobjects []*AutoIncrement
	err := o.All().Sort("Id", ASC).All(&pobjects)
	if err != nil {
		t.Error(err)
	}
	if len(pobjects) != count {
		t.Errorf("expecting %d objects, got %d instead", count, len(pobjects))
	}
	caps := o.Driver().Capabilities()
	autoId := caps&driver.CAP_AUTO_ID != 0
	autoIncrement := caps&driver.CAP_AUTO_INCREMENT != 0
	if autoId {
		if autoIncrement {
			for ii, v := range pobjects {
				exp := int64(ii + 1)
				if v.Id != exp {
					t.Errorf("expecting id %d at index %d, got %d instead", exp, ii, v.Id)
				}
			}
		} else {
			for ii := range pobjects {
				if ii > 0 {
					prev := pobjects[ii-1].Id
					cur := pobjects[ii].Id
					if prev >= cur {
						t.Errorf("id[%d] = %d >= id[%d] = %d", ii-1, prev, ii, cur)
					}
				}
			}
		}
	}

	var objects []AutoIncrement
	err = o.All().Sort("Id", DESC).All(&objects)
	if err != nil {
		t.Error(err)
	}
	if len(objects) != count {
		t.Errorf("expecting %d objects, got %d instead", count, len(objects))
	}
	if autoId {
		if autoIncrement {
			for ii, v := range objects {
				exp := int64(count - ii)
				if v.Id != exp {
					t.Errorf("expecting id %d at index %d, got %d instead", exp, ii, v.Id)
				}
			}
		} else {
			for ii := range objects {
				if ii > 0 {
					prev := objects[ii-1].Id
					cur := objects[ii].Id
					if prev <= cur {
						t.Errorf("id[%d] = %d <= id[%d] = %d", ii-1, prev, ii, cur)
					}
				}
			}
		}
	}
}

func testOrm(t *testing.T, o *Orm) {
	tests := []func(*testing.T, *Orm){
		testCodecs,
		testAutoIncrement,
		testTime,
		testSaveDelete,
		testLoadSaveMethods,
		testLoadSaveMethodsErrors,
		testData,
		testInnerPointer,
		testTransactions,
		testFuncTransactions,
		testCompositePrimaryKey,
		testReferences,
		testQueryAll,
	}
	for _, v := range tests {
		v(t, o)
	}
}
